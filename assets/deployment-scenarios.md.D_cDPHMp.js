import{_ as o,c as a,o as r,ag as t}from"./chunks/framework.Cycwnjj0.js";const h=JSON.parse('{"title":"Deployment Scenarios","description":"","frontmatter":{"title":"Deployment Scenarios","outline":[2,3],"head":[["link",{"rel":"canonical","href":"https://sqlrooms.org/deployment-scenarios.html"}]]},"headers":[],"relativePath":"deployment-scenarios.md","filePath":"deployment-scenarios.md"}'),s={name:"deployment-scenarios.md"};function n(l,e,i,c,d,p){return r(),a("div",null,[...e[0]||(e[0]=[t('<div style="display:none;" hidden="true" aria-hidden="true">Are you an LLM? You can read better optimized documentation at /deployment-scenarios.md for this page in Markdown format</div><h1 id="deployment-scenarios" tabindex="-1">Deployment Scenarios <a class="header-anchor" href="#deployment-scenarios" aria-label="Permalink to &quot;Deployment Scenarios&quot;">​</a></h1><p>SQLRooms supports multiple deployment models, from fully browser-only apps to server-backed collaborative setups. This guide helps teams choose a scenario based on infrastructure constraints, collaboration needs, and data governance requirements.</p><h2 id="_1-browser-only-analytics-for-read-mostly-use-cases-duckdb-wasm-object-storage" tabindex="-1">1) Browser-only analytics for read-mostly use cases (DuckDB WASM + object storage) <a class="header-anchor" href="#_1-browser-only-analytics-for-read-mostly-use-cases-duckdb-wasm-object-storage" aria-label="Permalink to &quot;1) Browser-only analytics for read-mostly use cases (DuckDB WASM + object storage)&quot;">​</a></h2><p>This is the simplest setup for traditional BI-style analytics with many managers using only a browser, especially when shared data is mostly consumed rather than collaboratively edited.</p><ul><li><strong>How it works:</strong> SQLRooms runs in the browser with DuckDB WASM, reading parquet (or other supported files) from object storage.</li><li><strong>Data storage:</strong> S3-compatible object storage (AWS S3, Cloudflare R2, MinIO, etc.).</li><li><strong>App state storage:</strong> Browser <code>localStorage</code> or IndexedDB; optionally OPFS for persisted DuckDB files.</li><li><strong>Access patterns:</strong> Signed URLs, backend-issued short-lived credentials, or DuckDB Secrets Manager where applicable.</li><li><strong>Best fit:</strong> Read-only or read-mostly self-service analytics with minimal backend operations.</li><li><strong>At a glance:</strong> Lowest ops complexity; low collaboration on shared data; partial/strong offline depending on caching and OPFS usage (offline is reduced if you rely on cloud persistence like MotherDuck).</li></ul><p>Examples and references:</p><ul><li><a href="/examples.html#ai-powered-analytics">AI example</a></li><li><a href="/examples.html#sql-query-editor">SQL Query Editor Example</a></li></ul><h2 id="_2-browser-clients-with-writable-shared-datasets" tabindex="-1">2) Browser clients with writable shared datasets <a class="header-anchor" href="#_2-browser-clients-with-writable-shared-datasets" aria-label="Permalink to &quot;2) Browser clients with writable shared datasets&quot;">​</a></h2><p>Use this scenario when teams need shared writable datasets with stronger governance and concurrency guarantees than individual parquet files.</p><ul><li><strong>How it works:</strong> Browser clients query and update shared datasets via a managed DuckDB backend (for example MotherDuck) or catalog-managed table formats such as Iceberg.</li><li><strong>Data storage:</strong> MotherDuck-managed DuckDB storage, or Iceberg tables in object storage with a catalog layer.</li><li><strong>App state storage:</strong> Browser local state and optionally backend metadata storage.</li><li><strong>Platform choice:</strong> See <a href="#backend-platform-options-for-scenarios-2-and-3">Backend platform options</a> for trade-offs between MotherDuck, Modal, Daytona, Cloudflare, and Plane.</li><li><strong>Best fit:</strong> Teams that need managed table lifecycle, concurrent writes, and shared editable data assets.</li><li><strong>At a glance:</strong> Moderate infra complexity; medium collaboration through shared writable tables; limited offline.</li></ul><p>Potential ecosystem options include <a href="https://motherduck.com/" target="_blank" rel="noreferrer">MotherDuck</a>, <a href="https://aws.amazon.com/s3/features/tables/" target="_blank" rel="noreferrer">Amazon S3 Tables</a>, and <a href="https://developers.cloudflare.com/r2/data-catalog/" target="_blank" rel="noreferrer">Cloudflare R2 Data Catalog</a>. Browser write/read capabilities depend on current DuckDB + browser connector support.</p><p>Reference:</p><ul><li><a href="https://duckdb.org/2025/12/16/iceberg-in-the-browser" target="_blank" rel="noreferrer">DuckDB: Iceberg in the Browser</a></li><li><a href="/examples.html#motherduck-cloud-query-editor">MotherDuck example</a></li></ul><h2 id="_3-collaborative-shared-rooms-with-sqlrooms-server-coming-soon" tabindex="-1">3) Collaborative shared rooms with <code>sqlrooms-server</code> (coming soon) <a class="header-anchor" href="#_3-collaborative-shared-rooms-with-sqlrooms-server-coming-soon" aria-label="Permalink to &quot;3) Collaborative shared rooms with `sqlrooms-server` (coming soon)&quot;">​</a></h2><p>Use server-backed sessions when many users need to see and edit the same analytical workspace in near real time.</p><ul><li><strong>How it works:</strong> A shared server runtime hosts DuckDB + sync endpoints; browser clients connect over WebSockets.</li><li><strong>Data storage:</strong> Server DuckDB database (with optional remote sources/extensions).</li><li><strong>Alternative persistence:</strong> MotherDuck can be used as a managed central DuckDB backend when you prefer hosted durability over self-managed database files.</li><li><strong>App state storage:</strong> Server-side metadata in the default meta schema or dedicated <code>--meta-db</code>, plus optional browser persistence.</li><li><strong>Platform choice:</strong> See <a href="#backend-platform-options-for-scenarios-2-and-3">Backend platform options</a> for trade-offs between managed persistence and per-room runtime platforms.</li><li><strong>Best fit:</strong> Team collaboration in a shared room, coordinated analysis, and synchronized state.</li><li><strong>At a glance:</strong> Highest collaboration; backend required; low offline for shared sessions.</li></ul><p>A common deployment pattern is session-per-room on demand (for example, containerized workers). One practical option is <a href="https://developers.cloudflare.com/containers/" target="_blank" rel="noreferrer">Cloudflare Containers</a>, which can spin up container instances on demand and route requests per session. Another option is <a href="https://www.daytona.io/" target="_blank" rel="noreferrer">Daytona</a>, which provides API-driven isolated sandboxes suitable for per-room runtime isolation and agent/tool execution workflows. <a href="https://plane.dev/" target="_blank" rel="noreferrer">Plane</a> is another self-hostable option that can run stateful WebSocket backends with per-session process isolation. <a href="https://modal.com/docs/guide/sandboxes" target="_blank" rel="noreferrer">Modal Sandbox</a> is also a strong fit for isolated compute environments, especially when paired with bursty heavier jobs.</p><p>Examples and references:</p><ul><li><a href="https://github.com/sqlrooms/examples/tree/main/sync" target="_blank" rel="noreferrer">Sync example</a></li><li><a href="https://github.com/sqlrooms/sqlrooms/tree/main/python/sqlrooms-server" target="_blank" rel="noreferrer"><code>sqlrooms-server</code> README</a></li><li><a href="https://modal.com/docs/examples/dbt_duckdb" target="_blank" rel="noreferrer">Build your own data warehouse with DuckDB, DBT, and Modal</a></li></ul><h2 id="backend-platform-options-for-scenarios-2-and-3" tabindex="-1">Backend platform options for Scenarios 2 and 3 <a class="header-anchor" href="#backend-platform-options-for-scenarios-2-and-3" aria-label="Permalink to &quot;Backend platform options for Scenarios 2 and 3&quot;">​</a></h2><p>In practice, teams can choose between managed data persistence (MotherDuck) and per-room compute runtimes (Modal/Daytona/Cloudflare/Plane), or combine them.</p><ul><li><strong>Use MotherDuck when:</strong> You have a business/enterprise budget and want managed DuckDB persistence, sharing, and operational simplicity. It is best as the durable data layer rather than the room runtime itself.</li><li><strong>Use Modal when:</strong> You want fast developer velocity for per-room isolated environments with persistent volumes and straightforward programmatic provisioning.</li><li><strong>Use Daytona when:</strong> You want API-driven per-room isolated sandboxes, strong runtime isolation for untrusted code or agent tools, and workspace-style execution environments.</li><li><strong>Use Cloudflare Containers when:</strong> You prioritize low baseline cost and edge proximity, and are comfortable implementing extra persistence orchestration (for example with R2) for sleeping/ephemeral instances.</li><li><strong>Use Plane when:</strong> You want a self-hostable system for stateful per-session WebSocket backends with full control over infrastructure behavior.</li></ul><p>Pricing and limits can change frequently, so treat platform economics as a regularly reviewed decision input.</p><h2 id="_4-local-session-backend-from-cli" tabindex="-1">4) Local session backend from CLI <a class="header-anchor" href="#_4-local-session-backend-from-cli" aria-label="Permalink to &quot;4) Local session backend from CLI&quot;">​</a></h2><p>This scenario is for single-user local workflows, similar to how Jupyter is often used: run a local backend process and connect from your browser.</p><ul><li><strong>How it works:</strong> Start <code>sqlrooms-cli</code> from CLI on your laptop, then point a local SQLRooms app to that local server endpoint.</li><li><strong>Data storage:</strong> Local DuckDB file (or <code>:memory:</code>), with optional remote sources/extensions.</li><li><strong>App state storage:</strong> Primarily local browser state, with optional server-side metadata tables.</li><li><strong>Best fit:</strong> Power users and developers who want local control, reproducibility, and a backend runtime without deploying shared infrastructure.</li><li><strong>At a glance:</strong> Simple local setup; strong privacy; no built-in team collaboration unless you later promote it to shared deployment.</li></ul><p>Reference:</p><ul><li><a href="https://github.com/sqlrooms/sqlrooms/tree/main/python/sqlrooms-cli" target="_blank" rel="noreferrer"><code>sqlrooms-cli</code> README</a></li></ul><h2 id="_5-offline-capable-pwa" tabindex="-1">5) Offline-capable PWA <a class="header-anchor" href="#_5-offline-capable-pwa" aria-label="Permalink to &quot;5) Offline-capable PWA&quot;">​</a></h2><p>Choose this for local-first experiences where users must continue working without network access.</p><ul><li><strong>How it works:</strong> SQLRooms is shipped as a PWA with service worker caching and local DuckDB persistence.</li><li><strong>Data storage:</strong> Browser OPFS (DuckDB files), local file imports.</li><li><strong>App state storage:</strong> <code>localStorage</code> or IndexedDB.</li><li><strong>Best fit:</strong> Offline analysis, privacy-first workflows, and disconnected environments.</li><li><strong>At a glance:</strong> Strong offline; simple architecture; collaboration is mostly asynchronous/manual.</li></ul><p>Examples and references:</p><ul><li><a href="https://sqlrooms.org/offline-use" target="_blank" rel="noreferrer">Offline Use</a></li><li><a href="https://github.com/sqlrooms/examples/tree/HEAD/query-pwa" target="_blank" rel="noreferrer">Query PWA example</a></li></ul><h2 id="_6-desktop-packaging-electron-tauri" tabindex="-1">6) Desktop packaging (Electron/Tauri) <a class="header-anchor" href="#_6-desktop-packaging-electron-tauri" aria-label="Permalink to &quot;6) Desktop packaging (Electron/Tauri)&quot;">​</a></h2><p>SQLRooms can be packaged as a desktop app using Electron or Tauri.</p><ul><li><strong>How it works:</strong> A desktop shell hosts the SQLRooms web app.</li><li><strong>Runtime options:</strong> In-app DuckDB WASM, or native DuckDB via a local backend such as <code>sqlrooms-server</code>.</li><li><strong>Data storage:</strong> Local filesystem/embedded database, optionally with remote sources.</li><li><strong>Alternative persistence:</strong> MotherDuck can back desktop deployments that need cloud-synced datasets across devices instead of only local files.</li><li><strong>App state storage:</strong> Local files and browser-like storage inside the desktop shell.</li><li><strong>Best fit:</strong> Organizations that prefer managed desktop distribution and local data residency.</li><li><strong>At a glance:</strong> Good for managed desktop environments; offline-friendly in local mode; collaboration depends on backend connectivity.</li></ul><p>Current status: SQLRooms does not provide direct Electron integration and there is no first-party Electron example today.</p><p>Reference:</p><ul><li><a href="/case-studies.html#foursquare-spatial-desktop">Foursquare Spatial Desktop case study</a></li></ul><h2 id="hybrid-setups" tabindex="-1">Hybrid setups <a class="header-anchor" href="#hybrid-setups" aria-label="Permalink to &quot;Hybrid setups&quot;">​</a></h2><p>Hybrid setups are also possible: start with browser-only or PWA for most users, and add server-backed shared rooms for teams that need real-time collaboration.</p>',42)])])}const u=o(s,[["render",n]]);export{h as __pageData,u as default};
